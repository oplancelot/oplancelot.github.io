I"' <p>These days there are a few tools that claim to (partially) replace a fully fledged Kubernetes cluster. Using them allows e.g. every developer to have their own local cluster instance running to play around with it, deploy their application or execute tests against applications running in K8s during CI/CD. In this post we’ll have a look at three of them, compare their pros and cons and identify use cases for each of them.</p>

<h2 id="minikube">minikube</h2>

<p>minikube is a Kubernetes SIGs project and has been started more than three years ago. It takes the approach of spawning a VM that is essentially a single node K8s cluster. Due to the support for a bunch of hypervisors it can be used on all of the major operating systems. This also allows you to create multiple instances in parallel.</p>

<p>From a user perspective minikube is a very beginner friendly tool. You start the cluster using <code class="language-plaintext highlighter-rouge">minikube start</code>, wait a few minutes and your <code class="language-plaintext highlighter-rouge">kubectl</code> is ready to go. To specify a Kubernetes version you can use the <code class="language-plaintext highlighter-rouge">--kubernetes-version</code> flag. A list of supported versions can be found <a href="https://minikube.sigs.k8s.io/docs/reference/configuration/kubernetes/">here</a>.</p>

<p>If you are new to Kubernetes the first class support for its dashboard that minikube offers may help you. With a simple <code class="language-plaintext highlighter-rouge">minikube dashboard</code> the application will open up giving you a nice overview of everything that is going on in your cluster. This is being achieved by <a href="https://minikube.sigs.k8s.io/docs/tasks/addons/">minikube’s addon system</a> that helps you integrating things like, <a href="https://helm.sh/">Helm</a>, <a href="https://developer.nvidia.com/kubernetes-gpu">Nvidia GPUs</a> and an <a href="https://docs.docker.com/registry/">image registry</a> with your cluster.</p>

<h2 id="kind">kind</h2>

<p>Kind is another Kubernetes SIGs project but is quite different compared to minikube. As the name suggests it moves the cluster into Docker containers. This leads to a significantly faster startup speed compared to spawning VM.</p>

<p>Creating a cluster is very similar to minikube’s approach. Executing <code class="language-plaintext highlighter-rouge">kind create cluster</code>, playing the waiting game and afterwards you are good to go. By using different names (<code class="language-plaintext highlighter-rouge">--name</code>) kind allows you to create multiple instances in parallel.</p>

<p>One feature that I personally enjoy is the ability to load my local images directly into the cluster. This saves me a few extra steps of setting up a registry and pushing my image each and every time I want to try out my changes. With a simple <code class="language-plaintext highlighter-rouge">kind load docker-image my-app:latest</code> the image is available for use in my cluster. Very nice!</p>

<p>If you are looking for a way to programmatically create a Kubernetes cluster, kind kindly (you have been for waiting for this, don’t you :P) publishes its Go packages that are used under the hood. If you want to get to know more have a look at the <a href="https://godoc.org/sigs.k8s.io/kind/pkg/cluster">GoDocs</a> and check out how <a href="https://github.com/kudobuilder/kudo/blob/f7b09025f5c2faf5492624facc1dc4c5c7a5ccad/pkg/test/harness.go#L105">KUDO uses kind for their integration tests</a>.</p>

<h2 id="k3s">k3s</h2>

<p>K3s is a minified version of Kubernetes developed by <a href="https://rancher.com/">Rancher Labs</a>. By removing dispensable features (legacy, alpha, non-default, in-tree plugins) and using lightweight components (e.g. sqlite3 instead of etcd3) they achieved a significant downsizing. This results in a single binary with a size of around 60 MB.</p>

<p>The application is split into the K3s server and the agent. The former acts as a manager while the latter is responsible for handling the actual workload. I discourage you from running them on your workstation as this leads to some clutter in your local filesystem. Instead put k3s in a container (e.g. by using <a href="https://hub.docker.com/r/rancher/k3s">rancher/k3s</a>) which also allows you to easily run several independent instances.</p>

<p>One feature that stands out is called <a href="https://rancher.com/docs/k3s/latest/en/configuration/#auto-deploying-manifests">auto deployment</a>. It allows you to deploy your Kubernetes manifests and Helm charts by putting them in a specific directory. K3s watches for changes and takes care of applying them without any further interaction. This is especially useful for CI pipelines and IoT devices (both target use cases of K3s). Just create/update your configuration and K3s makes sure to keep your deployments up to date.</p>

<h2 id="summary">Summary</h2>

<p>I was a long time minikube user as there where simply no alternatives (at least I never heard of one) and to be honest…it does a pretty good job at being a local Kubernetes development environment. You create the cluster, wait a few minutes and you are good to go. However for my use cases (mostly playing around with tools that run on K8s) I could fully replace it with kind due to the quicker setup time. If you are working in an environment with a tight resource pool or need an even quicker startup time, K3s is definitely a tool you should consider.</p>

<p>All in all these three tools are doing the job while using different approaches and focusing on different use cases. I hope you got a better understanding on how they work and which is the best candidate for solving your upcoming issue. Feel free to share your experience and let me know about use cases you are realizing with minikube, kind or k3s at <a href="https://twitter.com/__brennerm">@__brennerm</a>.</p>

<p>Below you can find a table that lists a few key facts of each tool.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: left">minikube</th>
      <th style="text-align: left">kind</th>
      <th style="text-align: left">k3s</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>runtime</td>
      <td style="text-align: left">VM</td>
      <td style="text-align: left">container</td>
      <td style="text-align: left">native</td>
    </tr>
    <tr>
      <td>supported architectures</td>
      <td style="text-align: left">AMD64</td>
      <td style="text-align: left">AMD64</td>
      <td style="text-align: left">AMD64, ARMv7, ARM64</td>
    </tr>
    <tr>
      <td>supported container runtimes</td>
      <td style="text-align: left">Docker,CRI-O,containerd,gvisor</td>
      <td style="text-align: left">Docker</td>
      <td style="text-align: left">Docker, containerd</td>
    </tr>
    <tr>
      <td>startup time initial/following</td>
      <td style="text-align: left">5:19 / 3:15</td>
      <td style="text-align: left">2:48 / 1:06</td>
      <td style="text-align: left">0:15 / 0:15</td>
    </tr>
    <tr>
      <td>memory requirements</td>
      <td style="text-align: left">2GB</td>
      <td style="text-align: left">8GB (Windows, MacOS)</td>
      <td style="text-align: left">512 MB</td>
    </tr>
    <tr>
      <td>requires root?</td>
      <td style="text-align: left">no</td>
      <td style="text-align: left">no</td>
      <td style="text-align: left">yes (rootless is experimental)</td>
    </tr>
    <tr>
      <td>multi-cluster support</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">no (can be achieved using containers)</td>
    </tr>
    <tr>
      <td>multi-node support</td>
      <td style="text-align: left">no</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">yes</td>
    </tr>
    <tr>
      <td>project page</td>
      <td style="text-align: left"><a href="https://minikube.sigs.k8s.io/">minikube</a></td>
      <td style="text-align: left"><a href="https://kind.sigs.k8s.io/">kind</a></td>
      <td style="text-align: left"><a href="https://k3s.io/">k3s</a></td>
    </tr>
  </tbody>
</table>

<hr />
:ET