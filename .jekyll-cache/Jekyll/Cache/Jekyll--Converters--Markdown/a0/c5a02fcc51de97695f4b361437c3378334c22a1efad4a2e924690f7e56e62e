I"v'<h2 id="1-the-problem">1. The problem</h2>

<p>Lately I was in need to periodically execute a Python script. To achieve this task my router, a <a href="https://www.tp-link.com/us/products/details/cat-9_TL-WDR3600.html">TP-Link N600</a>, running <a href="https://openwrt.org/">OpenWRT</a> Chaos Calmer came to my mind as it’s running the whole day anyway. So I checked the available packages in opkg, OpenWRT’s package manager, and found what I was looking for. Confidently executing <code class="language-plaintext highlighter-rouge">opkg install python3</code> (for Python 2 it’s <code class="language-plaintext highlighter-rouge">opkg install python</code>) resulted in the following</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Collected errors:
 * wfopen: /usr/lib/python2.7/encodings/mac_latin2.py: No space left on device.
 * wfopen: /usr/lib/python2.7/encodings/iso8859_3.py: No space left on device.
 * wfopen: /usr/lib/python2.7/encodings/iso8859_1.py: No space left on device.
 * wfopen: /usr/lib/python2.7/encodings/euc_kr.py: No space left on device.
 * wfopen: /usr/lib/python2.7/encodings/cp775.py: No space left on device.
 * pkg_write_filelist: Failed to open //usr/lib/opkg/info/python-codecs.list: No space left on device.
 * opkg_install_pkg: Failed to extract data files for python-codecs. Package debris may remain!
 * opkg_install_cmd: Cannot install package python.
 * opkg_conf_write_status_files: Can't open status file //usr/lib/opkg/status: No space left on device.
</code></pre></div></div>
<p>Well Shit! Being used to work with devices with loads of storage I didn’t expect that. <code class="language-plaintext highlighter-rouge">df</code> told me that my router has an incredible amount of 4.5, in words <strong>four dot five</strong>, megabytes of storage!</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@OpenWrt:~# df -h
Filesystem                Size      Used Available Use% Mounted on
rootfs                    4.5M      4.4M    108.0K  98% /
/dev/root                 2.3M      2.3M         0 100% /rom
tmpfs                    61.5M      1.2M     60.4M   2% /tmp
/dev/mtdblock3            4.5M      4.4M    108.0K  98% /overlay
overlayfs:/overlay        4.5M      4.4M    108.0K  98% /
tmpfs                   512.0K         0    512.0K   0% /dev
</code></pre></div></div>
<p>And so the journey began.</p>
<h2 id="2-looking-for-solutions">2. Looking for solutions</h2>
<p>After some investigation I found out that opkg supports custom installation paths for packages. The router’s RAM, mounted at /tmp, is one of the predefined targets. It’s advantage is that it provides a lot more storage (in my case 61.5Mb), but you may already have one concern. Right, as we’re working on volatile memory all data will be lost upon reboot.</p>

<p>As this was no option in my case I had to look further. Another solution would have been to use some kind of network storage and mount it via NFS. In my current environment I don’t have anything like that available to me so I went with the next obvious solution. Expanding my router’s storage using an USB device.</p>
<h2 id="3-accessing-a-usb-device">3. Accessing a USB device</h2>
<p>The support for USB devices is documented fairly good on the two pages about <a href="https://wiki.openwrt.org/doc/howto/usb.essentials">basic USB support</a> and <a href="https://wiki.openwrt.org/doc/howto/usb.storage">USB storage</a>. All I needed to do is to check the output of <code class="language-plaintext highlighter-rouge">dmesg</code> after plugging in my USB stick.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[5952821.750000] usb 1-1.1: new high-speed USB device number 3 using ehci-platform
</code></pre></div></div>

<p>In my case I had to install the driver for the ehci platform (USB 2.0).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>opkg update
opkg install kmod-usb2 kmod-usb-storage
insmod ehci-hcd
</code></pre></div></div>
<p>Afterwards the system detected the device and made it available at <em>/dev/sda</em>.</p>

<p>Depending on the partitioning of your device you may need to install support for further filesystems like ext4.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>opkg install kmod-fs-ext4
</code></pre></div></div>
<p>Now I was able to mount my USB stick.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mount -t ext4 /dev/sda1 /mnt/usb
</code></pre></div></div>
<p>As the mounting should happen automatically after every reboot installing the <code class="language-plaintext highlighter-rouge">block-mount</code> package, persisting the current mounts <code class="language-plaintext highlighter-rouge">block detect &gt; /etc/config/fstab</code> and enabling the autostart <code class="language-plaintext highlighter-rouge">/etc/init.d/fstab enable</code> was necessary. All that was left was to enable the automount for the USB device by editing the file <em>/etc/config/fstab</em>.</p>
<h2 id="4-installing-python-to-a-usb-device">4. Installing Python to a USB device</h2>
<p>With a working USB storage I needed to tell opkg to actually use it. This was done by adding the following the file <em>/etc/opkg.conf</em>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dest usb /mnt/usb
</code></pre></div></div>
<p>Installing packages to a non-default location may break. Some of the issues can be resolved by adjusting the path variables in <em>/etc/profile</em>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=$PATH:/mnt/usb/bin:/mnt/usb/sbin:/mnt/usb/usr/bin:/mnt/usb/usr/sbin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/mnt/usb/lib:/mnt/usb/usr/lib
</code></pre></div></div>
<p>Afterwards I was able to install Python using <code class="language-plaintext highlighter-rouge">opkg intall python3 -d usb</code>.
The OpenWrt docs suggest to precompile all Python modules to achieve a faster execution. <code class="language-plaintext highlighter-rouge">python -m compileall</code></p>

<p>Et voila, we have a running Python interpreter!</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">GCC</span> <span class="mf">4.8</span><span class="p">.</span><span class="mi">3</span><span class="p">]</span> <span class="n">on</span> <span class="n">linux</span>
<span class="n">Type</span> <span class="s">"help"</span><span class="p">,</span> <span class="s">"copyright"</span><span class="p">,</span> <span class="s">"credits"</span> <span class="ow">or</span> <span class="s">"license"</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="p">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">this</span>
<span class="n">The</span> <span class="n">Zen</span> <span class="n">of</span> <span class="n">Python</span><span class="p">,</span> <span class="n">by</span> <span class="n">Tim</span> <span class="n">Peters</span>

<span class="n">Beautiful</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">ugly</span><span class="p">.</span>
<span class="n">Explicit</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">implicit</span><span class="p">.</span>
<span class="n">Simple</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="nb">complex</span><span class="p">.</span>
<span class="n">Complex</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">complicated</span><span class="p">.</span>
<span class="n">Flat</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">nested</span><span class="p">.</span>
<span class="n">Sparse</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">dense</span><span class="p">.</span>
<span class="n">Readability</span> <span class="n">counts</span><span class="p">.</span>
<span class="n">Special</span> <span class="n">cases</span> <span class="n">aren</span><span class="s">'t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you'</span><span class="n">re</span> <span class="n">Dutch</span><span class="p">.</span>
<span class="n">Now</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">never</span><span class="p">.</span>
<span class="n">Although</span> <span class="n">never</span> <span class="ow">is</span> <span class="n">often</span> <span class="n">better</span> <span class="n">than</span> <span class="o">*</span><span class="n">right</span><span class="o">*</span> <span class="n">now</span><span class="p">.</span>
<span class="n">If</span> <span class="n">the</span> <span class="n">implementation</span> <span class="ow">is</span> <span class="n">hard</span> <span class="n">to</span> <span class="n">explain</span><span class="p">,</span> <span class="n">it</span><span class="s">'s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let'</span><span class="n">s</span> <span class="n">do</span> <span class="n">more</span> <span class="n">of</span> <span class="n">those</span><span class="err">!</span>
</code></pre></div></div>
<hr />
:ET